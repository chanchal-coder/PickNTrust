const express = require('express');
const path = require('path');
const fs = require('fs');
const cors = require('cors');
let BetterSqlite3;
try {
  BetterSqlite3 = require('better-sqlite3');
} catch (e) {
  console.warn('[Server] better-sqlite3 not available, will try sqlite3 fallback');
}

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors());

// Static files
app.use(express.static(path.join(__dirname, 'client/dist')));

// Database (unified_content)
const dbPath = path.join(__dirname, 'database.sqlite');
let sqliteDb;
if (BetterSqlite3) {
  try {
    sqliteDb = new BetterSqlite3(dbPath);
    console.log('[Server] Connected to SQLite (better-sqlite3) at', dbPath);
  } catch (e) {
    console.error('[Server] Failed to open SQLite with better-sqlite3:', e);
  }
}
if (!sqliteDb) {
  try {
    const sqlite3 = require('sqlite3').verbose();
    const Database = require('sqlite3').Database;
    // Simple wrapper to provide prepare().all() similar to better-sqlite3
    const connection = new Database(dbPath);
    console.log('[Server] Connected to SQLite (sqlite3) at', dbPath);
    sqliteDb = {
      prepare(sql) {
        return {
          all: (...params) => new Promise((resolve, reject) => {
            connection.all(sql, params, (err, rows) => {
              if (err) return reject(err);
              resolve(rows);
            });
          }),
        };
      },
    };
  } catch (e) {
    console.error('[Server] Failed to open SQLite database with sqlite3:', e);
    process.exit(1);
  }
}

// Helper: normalize product image
function toProxiedImage(url) {
  const u = typeof url === 'string' ? url.trim() : '';
  if (!u) return '/api/placeholder/300/300';
  if (u.startsWith('http://') || u.startsWith('https://')) return u; // keep original for simplicity
  return u; // relative/local
}

// Local placeholder image endpoint
app.get('/api/placeholder/:width/:height', (req, res) => {
  try {
    const width = Math.max(parseInt(req.params.width || '300', 10) || 300, 1);
    const height = Math.max(parseInt(req.params.height || '300', 10) || 300, 1);
    const text = req.query.text || 'No Image';
    const bg = req.query.bg || '#e5e7eb';
    const fg = req.query.fg || '#6b7280';
    res.setHeader('Content-Type', 'image/svg+xml');
    res.send(`<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">\n  <rect width="100%" height="100%" fill="${bg}"/>\n  <g fill="${fg}" font-family="Arial, Helvetica, sans-serif" font-size="${Math.max(Math.min(Math.floor(width / 10), 24), 12)}" text-anchor="middle">\n    <text x="50%" y="50%" dominant-baseline="middle">${text}</text>\n  </g>\n</svg>`);
  } catch (err) {
    console.error('Error generating placeholder image:', err);
    res.status(500).end();
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  try {
    res.json({ status: 'ok' });
  } catch (_) {
    res.status(200).json({ status: 'ok' });
  }
});

// Explicit API health/status endpoints to avoid SPA fallback
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok' });
});

app.get('/api/status', (req, res) => {
  res.json({ status: 'ok', time: new Date().toISOString() });
});

// Get products for a specific page using unified_content
app.get('/api/products/page/:page', async (req, res) => {
  try {
    const page = (req.params.page || '').trim();
    const category = (req.query.category || '').trim();
    const parsedLimit = Math.min(Math.max(parseInt(req.query.limit) || 50, 1), 100);
    const parsedOffset = Math.max(parseInt(req.query.offset) || 0, 0);

    if (!page) {
      return res.status(400).json({ message: 'Page parameter is required', error: 'INVALID_PARAMETERS' });
    }

    let query = `
      SELECT * FROM unified_content
      WHERE (status IN ('completed','active','processed') OR status IS NULL)
        AND (visibility = 'public' OR visibility IS NULL)
    `;
    const params = [];

    if (page === 'top-picks') {
      query += ' AND is_featured = 1';
    } else if (page === 'services') {
      query += ' AND is_service = 1';
    } else if (page === 'apps-ai-apps' || page === 'apps') {
      query += ' AND is_ai_app = 1';
    } else if (page === 'click-picks') {
      query += ` AND (
        display_pages LIKE '%click-picks%' OR
        display_pages = 'click-picks' OR
        page_type = 'click-picks'
      )`;
    } else if (page === 'prime-picks') {
      query += ` AND (
        display_pages LIKE '%' || ? || '%' OR
        display_pages = ? OR
        display_pages IS NULL OR
        display_pages = ''
      )`;
      params.push(page, page);
    } else {
      query += ` AND (
        display_pages LIKE '%' || ? || '%' OR
        display_pages = ?
      )`;
      params.push(page, page);
    }

    if (category && category !== 'all') {
      query += ' AND category = ?';
      params.push(category);
    }

    query += ' ORDER BY created_at DESC LIMIT ? OFFSET ?';
    params.push(parsedLimit, parsedOffset);

    const result = sqliteDb.prepare(query).all(...params);
    const rawProducts = typeof result?.then === 'function' ? await result : result;

    const products = rawProducts.map((product) => {
      try {
        const out = {
          id: product.id,
          name: product.title || 'Untitled Product',
          description: product.description || 'No description available',
          price: product.price,
          originalPrice: product.originalPrice,
          currency: product.currency || 'INR',
          imageUrl: product.imageUrl,
          affiliateUrl: product.affiliateUrl,
          category: product.category,
          rating: product.rating || 0,
          reviewCount: product.reviewCount || 0,
          discount: product.discount,
          isNew: product.isNew === 1,
          isFeatured: product.isFeatured === 1,
          createdAt: product.createdAt,
        };

        // Parse content JSON for price fields if missing
        if (product.content && (!out.price || !out.originalPrice)) {
          try {
            const c = JSON.parse(product.content);
            out.price = out.price || c.price;
            out.originalPrice = out.originalPrice || c.originalPrice;
            out.currency = out.currency || c.currency || 'INR';
            out.rating = out.rating || c.rating || 0;
            out.reviewCount = out.reviewCount || c.reviewCount || 0;
            out.discount = out.discount || c.discount;
          } catch (e) {
            // ignore parse error
          }
        }

        // Image from media_urls JSON
        if (product.media_urls && !out.imageUrl) {
          try {
            const medias = JSON.parse(product.media_urls);
            if (Array.isArray(medias) && medias.length > 0) {
              out.imageUrl = medias[0];
            }
          } catch (e) {}
        }
        if (!out.imageUrl && product.image_url) out.imageUrl = product.image_url;
        out.imageUrl = toProxiedImage(out.imageUrl);

        // Affiliate from affiliate_urls JSON
        if (product.affiliate_urls && !out.affiliateUrl) {
          try {
            const affs = JSON.parse(product.affiliate_urls);
            if (Array.isArray(affs) && affs.length > 0) {
              out.affiliateUrl = affs[0];
            }
          } catch (e) {}
        }
        if (!out.affiliateUrl && product.affiliateUrl) out.affiliateUrl = product.affiliateUrl;

        return out;
      } catch (e) {
        return {
          id: product.id || 0,
          name: product.title || 'Product Error',
          description: 'Error loading product details',
          price: 0,
          originalPrice: 0,
          currency: 'INR',
          imageUrl: null,
          affiliateUrl: null,
          category: 'Error',
          rating: 0,
          reviewCount: 0,
          discount: null,
          isNew: false,
          isFeatured: false,
          createdAt: product.createdAt || new Date().toISOString(),
        };
      }
    });

    console.log(`[API] /api/products/page/${page} -> ${products.length} items`);
    res.json(products);
  } catch (error) {
    console.error('Error in products page endpoint:', error);
    // Return an empty list on error to keep the UI functional
    res.json([]);
  }
});

// Get categories for a specific page
app.get('/api/categories/page/:page', async (req, res) => {
  try {
    const page = (req.params.page || '').trim();
    if (!page) return res.status(400).json({ message: 'Page parameter is required', error: 'INVALID_PARAMETERS' });

    const rowsResult = sqliteDb.prepare(`
      SELECT DISTINCT category FROM unified_content
      WHERE (
        display_pages LIKE '%' || ? || '%' OR
        display_pages = ? OR
        ( ? = 'prime-picks' AND (display_pages IS NULL OR display_pages = '') )
      )
      AND category IS NOT NULL AND category != ''
      AND (status IN ('completed','active','processed') OR status IS NULL)
    `).all(page, page, page);
    const rows = typeof rowsResult?.then === 'function' ? await rowsResult : rowsResult;

    const categories = rows.map(r => r.category).filter(Boolean).sort();
    res.json(categories);
  } catch (error) {
    console.error('Error fetching categories:', error);
    // Return empty array on error for resiliency
    res.json([]);
  }
});

// Fallback: React index.html
// Do NOT fallback for unknown /api paths; return JSON 404 instead
app.use((req, res, next) => {
  const p = (req.path || '').toString();
  if (p.startsWith('/api/')) {
    return res.status(404).json({ error: 'NOT_FOUND' });
  }
  next();
});

app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'client/dist/index.html'));
});

app.listen(PORT, () => {
  console.log(`[Server] PickNTrust production server running on port ${PORT}`);
});